/**
 * Quink, Copyright (c) 2013-2014 IMD - International Institute for Management Development, Switzerland.
 *
 * This file is part of Quink.
 * 
 * Quink is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Quink is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Quink.  If not, see <http://www.gnu.org/licenses/>.
 */

define([
    'jquery',
    'rangy',
    'util/PubSub'
], function ($, rangy, PubSub) {
    'use strict';

    var FocusTracker = function () {
        $('body').on('orientationchange', this.onOrientationChange);
    };

    FocusTracker.prototype.init = function (selector) {
        $(selector)
            .on('blur', this.onBlur.bind(this))
            .on('focus', this.onFocus.bind(this));
        // Ensure there's always an editable.
        this.editable = $(selector)[0];
        this.firstFocus = true;
    };

    /**
     * The event is generated by the browser before the orientation change is complete.
     * Wait until after completion. Would be better to detect this rather than go on a timer.
     */
    FocusTracker.prototype.onOrientationChange = function (event) {
        setTimeout(function () {
            PubSub.publish('event.orientationchange', event);
        }, 500);
    };

    FocusTracker.prototype.onBlur = function (event) {
        this.editable = event.target;
        this.saveState();
        PubSub.publish('editable.blur', this.editable);
    };

    FocusTracker.prototype.onFocus = function (event) {
        var old;
        if (event.target !== this.editable || this.firstFocus) {
            this.firstFocus = false;
            old = this.editable;
            this.editable = event.target;
            this.saveState();
            PubSub.publish('editable.change', {
                oldEditable: old,
                newEditable: this.editable
            });
        }
    };

    FocusTracker.prototype.restoreFocus = function () {
        var range = this.sel;
        if (this.editable) {
            this.editable.focus();
        }
        if (range) {
            rangy.getSelection().setSingleRange(range);
            this.sel = null;
        }
        if (this.bodyScrollTop) {
            $('body').scrollTop(this.bodyScrollTop);
            this.bodyScrollTop = 0;
        }
        if (this.scrollTop) {
            $(this.editable).scrollTop(this.scrollTop);
            this.scrollTop = 0;
        }
        return range;
    };

    FocusTracker.prototype.saveState = function () {
        var sel = rangy.getSelection();
        if (sel.rangeCount > 0) {
            this.sel = sel.getRangeAt(0);
        } else if (this.sel && $(this.sel.startContainer).closest(this.editable).length === 0) {
            // There is a selection, but it's not within the current editable.
            this.sel = null;
        }
        this.bodyScrollTop = $('body').scrollTop();
        this.scrollTop = $(this.editable).scrollTop();
    };

    FocusTracker.prototype.getEditable = function () {
        return $(this.editable);
    };

    var theInstance = new FocusTracker();

    return {
        init: theInstance.init.bind(theInstance),
        restoreFocus: theInstance.restoreFocus.bind(theInstance),
        saveState: theInstance.saveState.bind(theInstance),
        getEditable: theInstance.getEditable.bind(theInstance)
    };
});
